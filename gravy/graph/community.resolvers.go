package graph

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.86

import (
	"context"
	"fmt"
	"time"

	"github.com/pranava-mohan/wikinitt/gravy/graph/model"
	"github.com/pranava-mohan/wikinitt/gravy/internal/auth"
	"github.com/pranava-mohan/wikinitt/gravy/internal/community"
	"github.com/pranava-mohan/wikinitt/gravy/internal/sanitization"
	"github.com/pranava-mohan/wikinitt/gravy/internal/users"
)

// Replies is the resolver for the replies field.
func (r *commentResolver) Replies(ctx context.Context, obj *model.Comment, limit *int32, offset *int32) ([]*model.Comment, error) {
	l := 10
	o := 0
	if limit != nil {
		l = int(*limit)
	}
	if offset != nil {
		o = int(*offset)
	}

	replies, err := r.CommunityRepo.ListReplies(ctx, obj.ID, l, o)
	if err != nil {
		return nil, err
	}

	var modelReplies []*model.Comment
	for _, reply := range replies {

		author, _ := r.UserRepo.GetByID(ctx, reply.AuthorID)
		authorPublic := &users.PublicUser{
			ID:          author.ID,
			Name:        author.Name,
			Username:    author.Username,
			DisplayName: author.DisplayName,
			Gender:      author.Gender,
			Avatar:      author.Avatar,
		}

		post, _ := r.CommunityRepo.GetPost(ctx, reply.PostID)
		postAuthor, _ := r.UserRepo.GetByID(ctx, post.AuthorID)
		postAuthorPublic := &users.PublicUser{
			ID:          postAuthor.ID,
			Name:        postAuthor.Name,
			Username:    postAuthor.Username,
			DisplayName: postAuthor.DisplayName,
			Gender:      postAuthor.Gender,
			Avatar:      postAuthor.Avatar,
		}

		group, _ := r.CommunityRepo.GetGroupByID(ctx, post.GroupID)
		groupOwner, _ := r.UserRepo.GetByID(ctx, group.OwnerID)
		groupOwnerPublic := &users.PublicUser{
			ID:          groupOwner.ID,
			Name:        groupOwner.Name,
			Username:    groupOwner.Username,
			DisplayName: groupOwner.DisplayName,
			Gender:      groupOwner.Gender,
			Avatar:      groupOwner.Avatar,
		}

		replyModel := mapCommentToModel(reply, authorPublic, post, postAuthorPublic, group, groupOwnerPublic)

		user := auth.ForContext(ctx)
		if user != nil {
			voteType, _ := r.CommunityRepo.GetUserCommentVote(ctx, user.ID, reply.ID)
			switch voteType {
			case "UP":
				replyModel.UserVote = model.VoteTypeUp
			case "DOWN":
				replyModel.UserVote = model.VoteTypeDown
			default:
				replyModel.UserVote = model.VoteTypeNone
			}
		}

		modelReplies = append(modelReplies, replyModel)
	}

	return modelReplies, nil
}

// UserVote is the resolver for the userVote field.
func (r *commentResolver) UserVote(ctx context.Context, obj *model.Comment) (model.VoteType, error) {
	user := auth.ForContext(ctx)
	if user == nil {
		return model.VoteTypeNone, nil
	}
	voteType, err := r.CommunityRepo.GetUserCommentVote(ctx, user.ID, obj.ID)
	if err != nil {
		return model.VoteTypeNone, nil
	}
	switch voteType {
	case "UP":
		return model.VoteTypeUp, nil
	case "DOWN":
		return model.VoteTypeDown, nil
	default:
		return model.VoteTypeNone, nil
	}
}

// IsMember is the resolver for the isMember field.
func (r *groupResolver) IsMember(ctx context.Context, obj *model.Group) (bool, error) {
	user := auth.ForContext(ctx)
	if user == nil {
		return false, nil
	}
	return r.CommunityRepo.IsMember(ctx, obj.ID, user.ID)
}

// Posts is the resolver for the posts field.
func (r *groupResolver) Posts(ctx context.Context, obj *model.Group, limit *int32, offset *int32) ([]*model.Post, error) {
	l := 10
	o := 0
	if limit != nil {
		l = int(*limit)
	}
	if offset != nil {
		o = int(*offset)
	}

	if obj.Type == model.GroupTypePrivate {
		user := auth.ForContext(ctx)
		if user == nil {
			return nil, fmt.Errorf("access denied: private group")
		}
		isMember, err := r.CommunityRepo.IsMember(ctx, obj.ID, user.ID)
		if err != nil {
			return nil, err
		}
		if !isMember {
			return nil, fmt.Errorf("access denied: must be a member to view posts")
		}
	}

	posts, err := r.CommunityRepo.ListPosts(ctx, obj.ID, l, o)
	if err != nil {
		return nil, err
	}

	var modelPosts []*model.Post
	for _, p := range posts {
		author, _ := r.UserRepo.GetByID(ctx, p.AuthorID)
		authorPublic := &users.PublicUser{
			ID:          author.ID,
			Name:        author.Name,
			Username:    author.Username,
			DisplayName: author.DisplayName,
			Gender:      author.Gender,
			Avatar:      author.Avatar,
		}

		group, _ := r.CommunityRepo.GetGroupByID(ctx, p.GroupID)
		groupOwner, _ := r.UserRepo.GetByID(ctx, group.OwnerID)
		groupOwnerPublic := &users.PublicUser{
			ID:          groupOwner.ID,
			Name:        groupOwner.Name,
			Username:    groupOwner.Username,
			DisplayName: groupOwner.DisplayName,
			Gender:      groupOwner.Gender,
			Avatar:      groupOwner.Avatar,
		}

		modelPosts = append(modelPosts, mapPostToModel(p, authorPublic, group, groupOwnerPublic))
	}
	return modelPosts, nil
}

// InviteToken is the resolver for the inviteToken field.
func (r *groupResolver) InviteToken(ctx context.Context, obj *model.Group) (*string, error) {
	user := auth.ForContext(ctx)
	if user == nil {
		return nil, nil
	}

	if user.ID != obj.Owner.ID {
		return nil, nil // Only owner can see
	}

	g, err := r.CommunityRepo.GetGroupByID(ctx, obj.ID)
	if err != nil {
		return nil, nil
	}
	if g.InviteToken == "" {
		return nil, nil
	}
	return &g.InviteToken, nil
}

// JoinRequests is the resolver for the joinRequests field.
func (r *groupResolver) JoinRequests(ctx context.Context, obj *model.Group) ([]*model.PublicUser, error) {
	user := auth.ForContext(ctx)
	if user == nil {
		return nil, nil
	}

	if user.ID != obj.Owner.ID {
		return nil, nil // Only owner can see
	}

	g, err := r.CommunityRepo.GetGroupByID(ctx, obj.ID)
	if err != nil {
		return nil, nil
	}

	var requests []*model.PublicUser
	for _, uid := range g.JoinRequestIDs {
		u, err := r.UserRepo.GetByID(ctx, uid)
		if err == nil {
			requests = append(requests, mapPublicUserToModel(mapUserToPublic(u)))
		}
	}
	return requests, nil
}

// Members is the resolver for the members field.
func (r *groupResolver) Members(ctx context.Context, obj *model.Group) ([]*model.PublicUser, error) {
	user := auth.ForContext(ctx)
	if user == nil {
		return nil, nil
	}

	isMember, _ := r.CommunityRepo.IsMember(ctx, obj.ID, user.ID)
	if !isMember && user.ID != obj.Owner.ID {
		// Only members and owner see members list
		return nil, nil
	}

	g, err := r.CommunityRepo.GetGroupByID(ctx, obj.ID)
	if err != nil {
		return nil, nil
	}

	var members []*model.PublicUser
	for _, uid := range g.MemberIDs {
		u, err := r.UserRepo.GetByID(ctx, uid)
		if err == nil {
			members = append(members, mapPublicUserToModel(mapUserToPublic(u)))
		}
	}
	return members, nil
}

// HasPendingRequest is the resolver for the hasPendingRequest field.
func (r *groupResolver) HasPendingRequest(ctx context.Context, obj *model.Group) (bool, error) {
	user := auth.ForContext(ctx)
	if user == nil {
		return false, nil
	}

	g, err := r.CommunityRepo.GetGroupByID(ctx, obj.ID)
	if err != nil {
		return false, err
	}

	for _, uid := range g.JoinRequestIDs {
		if uid == user.ID {
			return true, nil
		}
	}
	return false, nil
}

// CreateGroup is the resolver for the createGroup field.
func (r *mutationResolver) CreateGroup(ctx context.Context, input model.NewGroup) (*model.Group, error) {
	user := auth.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	baseSlug := generateSlug(input.Name)
	slug := baseSlug

	for {
		_, err := r.CommunityRepo.GetGroup(ctx, slug)
		if err != nil {

			break
		}

		slug = fmt.Sprintf("%s-%s", baseSlug, randString(6))
	}

	group := &community.Group{
		Name:         input.Name,
		Description:  input.Description,
		Slug:         slug,
		Type:         community.GroupType(input.Type),
		OwnerID:      user.ID,
		MembersCount: 1,
		MemberIDs:    []string{user.ID},
		CreatedAt:    time.Now(),
	}

	err := r.CommunityRepo.CreateGroup(ctx, group)
	if err != nil {
		return nil, err
	}

	owner := &users.PublicUser{
		ID:          user.ID,
		Name:        user.Name,
		Username:    user.Username,
		DisplayName: user.DisplayName,
		Gender:      user.Gender,
		Avatar:      user.Avatar,
	}

	return mapGroupToModel(group, owner), nil
}

// JoinGroup is the resolver for the joinGroup field.
func (r *mutationResolver) JoinGroup(ctx context.Context, groupID string) (bool, error) {
	user := auth.ForContext(ctx)
	if user == nil {
		return false, fmt.Errorf("not authenticated")
	}

	// Check group type
	group, err := r.CommunityRepo.GetGroupByID(ctx, groupID)
	if err != nil {
		return false, err
	}

	if group.Type == community.GroupTypePrivate {
		return false, fmt.Errorf("cannot join private group directly")
	}

	err = r.CommunityRepo.JoinGroup(ctx, groupID, user.ID)
	if err != nil {
		return false, err
	}
	return true, nil
}

// LeaveGroup is the resolver for the leaveGroup field.
func (r *mutationResolver) LeaveGroup(ctx context.Context, groupID string) (bool, error) {
	user := auth.ForContext(ctx)
	if user == nil {
		return false, fmt.Errorf("not authenticated")
	}

	err := r.CommunityRepo.LeaveGroup(ctx, groupID, user.ID)
	if err != nil {
		return false, err
	}
	return true, nil
}

// CreatePost is the resolver for the createPost field.
func (r *mutationResolver) CreatePost(ctx context.Context, input model.NewPost) (*model.Post, error) {
	user := auth.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	isMember, err := r.CommunityRepo.IsMember(ctx, input.GroupID, user.ID)
	if err != nil {
		return nil, err
	}
	if !isMember {
		return nil, fmt.Errorf("must be a member of the group to create a post")
	}

	post := &community.Post{
		Title:     input.Title,
		Content:   sanitization.SanitizeContent(input.Content),
		AuthorID:  user.ID,
		GroupID:   input.GroupID,
		CreatedAt: time.Now(),
	}

	err = r.CommunityRepo.CreatePost(ctx, post)
	if err != nil {
		return nil, err
	}

	group, err := r.CommunityRepo.GetGroupByID(ctx, input.GroupID)
	if err != nil {
		return nil, err
	}
	groupOwner, _ := r.UserRepo.GetByID(ctx, group.OwnerID)
	groupOwnerPublic := &users.PublicUser{
		ID:          groupOwner.ID,
		Name:        groupOwner.Name,
		Username:    groupOwner.Username,
		DisplayName: groupOwner.DisplayName,
		Gender:      groupOwner.Gender,
		Avatar:      groupOwner.Avatar,
	}

	author := &users.PublicUser{
		ID:          user.ID,
		Name:        user.Name,
		Username:    user.Username,
		DisplayName: user.DisplayName,
		Gender:      user.Gender,
		Avatar:      user.Avatar,
	}

	return mapPostToModel(post, author, group, groupOwnerPublic), nil
}

// CreateComment is the resolver for the createComment field.
func (r *mutationResolver) CreateComment(ctx context.Context, input model.NewComment) (*model.Comment, error) {
	user := auth.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	comment := &community.Comment{
		Content:   sanitization.SanitizeContent(input.Content),
		AuthorID:  user.ID,
		PostID:    input.PostID,
		ParentID:  input.ParentID,
		CreatedAt: time.Now(),
	}

	err := r.CommunityRepo.CreateComment(ctx, comment)
	if err != nil {
		return nil, err
	}

	post, _ := r.CommunityRepo.GetPost(ctx, input.PostID)
	postAuthor, _ := r.UserRepo.GetByID(ctx, post.AuthorID)
	postAuthorPublic := &users.PublicUser{
		ID:          postAuthor.ID,
		Name:        postAuthor.Name,
		Username:    postAuthor.Username,
		DisplayName: postAuthor.DisplayName,
		Gender:      postAuthor.Gender,
		Avatar:      postAuthor.Avatar,
	}
	group, _ := r.CommunityRepo.GetGroupByID(ctx, post.GroupID)
	groupOwner, _ := r.UserRepo.GetByID(ctx, group.OwnerID)
	groupOwnerPublic := &users.PublicUser{
		ID:          groupOwner.ID,
		Name:        groupOwner.Name,
		Username:    groupOwner.Username,
		DisplayName: groupOwner.DisplayName,
		Gender:      groupOwner.Gender,
		Avatar:      groupOwner.Avatar,
	}

	author := &users.PublicUser{
		ID:          user.ID,
		Name:        user.Name,
		Username:    user.Username,
		DisplayName: user.DisplayName,
		Gender:      user.Gender,
		Avatar:      user.Avatar,
	}

	return mapCommentToModel(comment, author, post, postAuthorPublic, group, groupOwnerPublic), nil
}

// VotePost is the resolver for the votePost field.
func (r *mutationResolver) VotePost(ctx context.Context, postID string, typeArg model.VoteType) (*model.Post, error) {
	user := auth.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	err := r.CommunityRepo.VotePost(ctx, user.ID, postID, typeArg.String())
	if err != nil {
		return nil, err
	}

	return r.Query().Post(ctx, postID)
}

// VoteComment is the resolver for the voteComment field.
func (r *mutationResolver) VoteComment(ctx context.Context, commentID string, typeArg model.VoteType) (*model.Comment, error) {
	user := auth.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	err := r.CommunityRepo.VoteComment(ctx, user.ID, commentID, typeArg.String())
	if err != nil {
		return nil, err
	}

	c, err := r.CommunityRepo.GetComment(ctx, commentID)
	if err != nil {
		return nil, err
	}

	author, _ := r.UserRepo.GetByID(ctx, c.AuthorID)
	authorPublic := &users.PublicUser{
		ID:          author.ID,
		Name:        author.Name,
		Username:    author.Username,
		DisplayName: author.DisplayName,
		Gender:      author.Gender,
		Avatar:      author.Avatar,
	}

	post, _ := r.CommunityRepo.GetPost(ctx, c.PostID)
	postAuthor, _ := r.UserRepo.GetByID(ctx, post.AuthorID)
	postAuthorPublic := &users.PublicUser{
		ID:          postAuthor.ID,
		Name:        postAuthor.Name,
		Username:    postAuthor.Username,
		DisplayName: postAuthor.DisplayName,
		Gender:      postAuthor.Gender,
		Avatar:      postAuthor.Avatar,
	}

	group, _ := r.CommunityRepo.GetGroupByID(ctx, post.GroupID)
	groupOwner, _ := r.UserRepo.GetByID(ctx, group.OwnerID)
	groupOwnerPublic := &users.PublicUser{
		ID:          groupOwner.ID,
		Name:        groupOwner.Name,
		Username:    groupOwner.Username,
		DisplayName: groupOwner.DisplayName,
		Gender:      groupOwner.Gender,
		Avatar:      groupOwner.Avatar,
	}

	result := mapCommentToModel(c, authorPublic, post, postAuthorPublic, group, groupOwnerPublic)

	voteType, _ := r.CommunityRepo.GetUserCommentVote(ctx, user.ID, commentID)
	switch voteType {
	case "UP":
		result.UserVote = model.VoteTypeUp
	case "DOWN":
		result.UserVote = model.VoteTypeDown
	default:
		result.UserVote = model.VoteTypeNone
	}

	return result, nil
}

// UpdateGroup is the resolver for the updateGroup field.
func (r *mutationResolver) UpdateGroup(ctx context.Context, groupID string, name *string, description *string, icon *string) (*model.Group, error) {
	user := auth.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	group, err := r.CommunityRepo.GetGroupByID(ctx, groupID)
	if err != nil {
		return nil, err
	}

	if group.OwnerID != user.ID {
		return nil, fmt.Errorf("access denied: only group owner can edit")
	}

	updatedGroup, err := r.CommunityRepo.UpdateGroup(ctx, groupID, name, description, icon)
	if err != nil {
		return nil, err
	}

	owner, _ := r.UserRepo.GetByID(ctx, updatedGroup.OwnerID)
	return mapGroupToModel(updatedGroup, mapUserToPublic(owner)), nil
}

// GenerateGroupInvite is the resolver for the generateGroupInvite field.
func (r *mutationResolver) GenerateGroupInvite(ctx context.Context, groupID string) (string, error) {
	user := auth.ForContext(ctx)
	if user == nil {
		return "", fmt.Errorf("not authenticated")
	}

	group, err := r.CommunityRepo.GetGroupByID(ctx, groupID)
	if err != nil {
		return "", err
	}

	if group.OwnerID != user.ID {
		return "", fmt.Errorf("access denied: only owner can generate invite")
	}

	return r.CommunityRepo.GenerateInviteToken(ctx, groupID)
}

// RequestJoinGroup is the resolver for the requestJoinGroup field.
func (r *mutationResolver) RequestJoinGroup(ctx context.Context, groupID string, token string) (bool, error) {
	user := auth.ForContext(ctx)
	if user == nil {
		return false, fmt.Errorf("not authenticated")
	}

	group, err := r.CommunityRepo.GetGroupByInviteToken(ctx, token)
	if err != nil {
		return false, fmt.Errorf("invalid token")
	}

	if group.ID != groupID {
		return false, fmt.Errorf("invalid token for this group")
	}

	// Check if already member
	isMember, _ := r.CommunityRepo.IsMember(ctx, groupID, user.ID)
	if isMember {
		return true, nil // Already member
	}

	err = r.CommunityRepo.AddJoinRequest(ctx, groupID, user.ID)
	if err != nil {
		return false, err
	}

	return true, nil
}

// AcceptJoinRequest is the resolver for the acceptJoinRequest field.
func (r *mutationResolver) AcceptJoinRequest(ctx context.Context, groupID string, userID string) (bool, error) {
	user := auth.ForContext(ctx)
	if user == nil {
		return false, fmt.Errorf("not authenticated")
	}

	group, err := r.CommunityRepo.GetGroupByID(ctx, groupID)
	if err != nil {
		return false, err
	}

	if group.OwnerID != user.ID {
		return false, fmt.Errorf("access denied")
	}

	err = r.CommunityRepo.JoinGroup(ctx, groupID, userID)
	if err != nil {
		return false, err
	}

	_ = r.CommunityRepo.RemoveJoinRequest(ctx, groupID, userID)
	return true, nil
}

// RejectJoinRequest is the resolver for the rejectJoinRequest field.
func (r *mutationResolver) RejectJoinRequest(ctx context.Context, groupID string, userID string) (bool, error) {
	user := auth.ForContext(ctx)
	if user == nil {
		return false, fmt.Errorf("not authenticated")
	}

	group, err := r.CommunityRepo.GetGroupByID(ctx, groupID)
	if err != nil {
		return false, err
	}

	if group.OwnerID != user.ID {
		return false, fmt.Errorf("access denied")
	}

	err = r.CommunityRepo.RemoveJoinRequest(ctx, groupID, userID)
	if err != nil {
		return false, err
	}
	return true, nil
}

// RemoveMember is the resolver for the removeMember field.
func (r *mutationResolver) RemoveMember(ctx context.Context, groupID string, userID string) (bool, error) {
	user := auth.ForContext(ctx)
	if user == nil {
		return false, fmt.Errorf("not authenticated")
	}

	group, err := r.CommunityRepo.GetGroupByID(ctx, groupID)
	if err != nil {
		return false, err
	}

	if group.OwnerID != user.ID {
		return false, fmt.Errorf("access denied")
	}

	if group.OwnerID == userID {
		return false, fmt.Errorf("cannot remove owner")
	}

	err = r.CommunityRepo.RemoveMember(ctx, groupID, userID)
	if err != nil {
		return false, err
	}
	return true, nil
}

// UpdatePost is the resolver for the updatePost field.
func (r *mutationResolver) UpdatePost(ctx context.Context, postID string, title *string, content *string) (*model.Post, error) {
	user := auth.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	post, err := r.CommunityRepo.GetPost(ctx, postID)
	if err != nil {
		return nil, err
	}

	// Check if user is author or admin
	if post.AuthorID != user.ID && !user.IsAdmin {
		return nil, fmt.Errorf("access denied: only author or admin can edit")
	}

	var sanitizedContent *string
	if content != nil {
		c := sanitization.SanitizeContent(*content)
		sanitizedContent = &c
	}

	updatedPost, err := r.CommunityRepo.UpdatePost(ctx, postID, title, sanitizedContent)
	if err != nil {
		return nil, err
	}

	author, _ := r.UserRepo.GetByID(ctx, updatedPost.AuthorID)
	authorPublic := &users.PublicUser{
		ID:          author.ID,
		Name:        author.Name,
		Username:    author.Username,
		DisplayName: author.DisplayName,
		Gender:      author.Gender,
		Avatar:      author.Avatar,
	}

	group, _ := r.CommunityRepo.GetGroupByID(ctx, updatedPost.GroupID)
	groupOwner, _ := r.UserRepo.GetByID(ctx, group.OwnerID)
	groupOwnerPublic := &users.PublicUser{
		ID:          groupOwner.ID,
		Name:        groupOwner.Name,
		Username:    groupOwner.Username,
		DisplayName: groupOwner.DisplayName,
		Gender:      groupOwner.Gender,
		Avatar:      groupOwner.Avatar,
	}

	return mapPostToModel(updatedPost, authorPublic, group, groupOwnerPublic), nil
}

// DeletePost is the resolver for the deletePost field.
func (r *mutationResolver) DeletePost(ctx context.Context, postID string) (bool, error) {
	user := auth.ForContext(ctx)
	if user == nil {
		return false, fmt.Errorf("not authenticated")
	}

	post, err := r.CommunityRepo.GetPost(ctx, postID)
	if err != nil {
		return false, err
	}

	// Check if user is author or admin
	if post.AuthorID != user.ID && !user.IsAdmin {
		return false, fmt.Errorf("access denied: only author or admin can delete")
	}

	err = r.CommunityRepo.DeletePost(ctx, postID)
	if err != nil {
		return false, err
	}

	return true, nil
}

// UpdateComment is the resolver for the updateComment field.
func (r *mutationResolver) UpdateComment(ctx context.Context, commentID string, content string) (*model.Comment, error) {
	user := auth.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	comment, err := r.CommunityRepo.GetComment(ctx, commentID)
	if err != nil {
		return nil, err
	}

	// Check if user is author or admin
	if comment.AuthorID != user.ID && !user.IsAdmin {
		return nil, fmt.Errorf("access denied: only author or admin can edit")
	}

	sanitizedContent := sanitization.SanitizeContent(content)
	updatedComment, err := r.CommunityRepo.UpdateComment(ctx, commentID, sanitizedContent)
	if err != nil {
		return nil, err
	}

	author, _ := r.UserRepo.GetByID(ctx, updatedComment.AuthorID)
	authorPublic := &users.PublicUser{
		ID:          author.ID,
		Name:        author.Name,
		Username:    author.Username,
		DisplayName: author.DisplayName,
		Gender:      author.Gender,
		Avatar:      author.Avatar,
	}

	post, _ := r.CommunityRepo.GetPost(ctx, updatedComment.PostID)
	postAuthor, _ := r.UserRepo.GetByID(ctx, post.AuthorID)
	postAuthorPublic := &users.PublicUser{
		ID:          postAuthor.ID,
		Name:        postAuthor.Name,
		Username:    postAuthor.Username,
		DisplayName: postAuthor.DisplayName,
		Gender:      postAuthor.Gender,
		Avatar:      postAuthor.Avatar,
	}

	group, _ := r.CommunityRepo.GetGroupByID(ctx, post.GroupID)
	groupOwner, _ := r.UserRepo.GetByID(ctx, group.OwnerID)
	groupOwnerPublic := &users.PublicUser{
		ID:          groupOwner.ID,
		Name:        groupOwner.Name,
		Username:    groupOwner.Username,
		DisplayName: groupOwner.DisplayName,
		Gender:      groupOwner.Gender,
		Avatar:      groupOwner.Avatar,
	}

	return mapCommentToModel(updatedComment, authorPublic, post, postAuthorPublic, group, groupOwnerPublic), nil
}

// DeleteComment is the resolver for the deleteComment field.
func (r *mutationResolver) DeleteComment(ctx context.Context, commentID string) (bool, error) {
	user := auth.ForContext(ctx)
	if user == nil {
		return false, fmt.Errorf("not authenticated")
	}

	comment, err := r.CommunityRepo.GetComment(ctx, commentID)
	if err != nil {
		return false, err
	}

	// Check if user is author or admin
	if comment.AuthorID != user.ID && !user.IsAdmin {
		return false, fmt.Errorf("access denied: only author or admin can delete")
	}

	err = r.CommunityRepo.DeleteComment(ctx, commentID)
	if err != nil {
		return false, err
	}

	return true, nil
}

// UserVote is the resolver for the userVote field.
func (r *postResolver) UserVote(ctx context.Context, obj *model.Post) (model.VoteType, error) {
	user := auth.ForContext(ctx)
	if user == nil {
		return model.VoteTypeNone, nil
	}
	voteType, err := r.CommunityRepo.GetUserVote(ctx, user.ID, obj.ID)
	if err != nil {
		return model.VoteTypeNone, nil
	}
	switch voteType {
	case "UP":
		return model.VoteTypeUp, nil
	case "DOWN":
		return model.VoteTypeDown, nil
	default:
		return model.VoteTypeNone, nil
	}
}

// Comments is the resolver for the comments field.
func (r *postResolver) Comments(ctx context.Context, obj *model.Post, limit *int32, offset *int32) ([]*model.Comment, error) {
	l := 10
	o := 0
	if limit != nil {
		l = int(*limit)
	}
	if offset != nil {
		o = int(*offset)
	}

	comments, err := r.CommunityRepo.ListComments(ctx, obj.ID, nil, l, o)
	if err != nil {
		return nil, err
	}

	var modelComments []*model.Comment
	for _, c := range comments {
		author, err := r.UserRepo.GetByID(ctx, c.AuthorID)
		var authorPublic *users.PublicUser
		if err != nil {

			authorPublic = &users.PublicUser{
				ID:          "unknown",
				Name:        "Unknown User",
				Username:    "unknown",
				DisplayName: "Unknown User",
				Gender:      "unknown",
				Avatar:      "",
			}
		} else {
			authorPublic = &users.PublicUser{
				ID:          author.ID,
				Name:        author.Name,
				Username:    author.Username,
				DisplayName: author.DisplayName,
				Gender:      author.Gender,
				Avatar:      author.Avatar,
			}
		}

		post, err := r.CommunityRepo.GetPost(ctx, c.PostID)
		if err != nil {

			post = &community.Post{
				ID:      c.PostID,
				Title:   "Unknown Post",
				Content: "Unknown Content",
				GroupID: "unknown",
			}
		}

		postAuthor, err := r.UserRepo.GetByID(ctx, post.AuthorID)
		var postAuthorPublic *users.PublicUser
		if err != nil {

			postAuthorPublic = &users.PublicUser{
				ID:       "unknown",
				Name:     "Unknown",
				Username: "unknown",
			}
		} else {
			postAuthorPublic = &users.PublicUser{
				ID:          postAuthor.ID,
				Name:        postAuthor.Name,
				Username:    postAuthor.Username,
				DisplayName: postAuthor.DisplayName,
				Gender:      postAuthor.Gender,
				Avatar:      postAuthor.Avatar,
			}
		}

		group, err := r.CommunityRepo.GetGroupByID(ctx, post.GroupID)
		if err != nil {
			group = &community.Group{
				ID:   post.GroupID,
				Name: "Unknown Group",
				Slug: "unknown",
				Type: community.GroupTypePublic,
			}
		}

		groupOwner, err := r.UserRepo.GetByID(ctx, group.OwnerID)
		var groupOwnerPublic *users.PublicUser
		if err != nil {
			groupOwnerPublic = &users.PublicUser{
				ID:       "unknown",
				Name:     "Unknown",
				Username: "unknown",
			}
		} else {
			groupOwnerPublic = &users.PublicUser{
				ID:          groupOwner.ID,
				Name:        groupOwner.Name,
				Username:    groupOwner.Username,
				DisplayName: groupOwner.DisplayName,
				Gender:      groupOwner.Gender,
				Avatar:      groupOwner.Avatar,
			}
		}

		modelComments = append(modelComments, mapCommentToModel(c, authorPublic, post, postAuthorPublic, group, groupOwnerPublic))
	}
	return modelComments, nil
}

// PublicGroups is the resolver for the publicGroups field.
func (r *queryResolver) PublicGroups(ctx context.Context, limit *int32, offset *int32) ([]*model.Group, error) {
	l := 10
	o := 0
	if limit != nil {
		l = int(*limit)
	}
	if offset != nil {
		o = int(*offset)
	}

	filter := community.GroupFilter{}
	t := community.GroupTypePublic
	filter.Type = &t

	groups, err := r.CommunityRepo.ListGroups(ctx, filter, l, o)
	if err != nil {
		return nil, err
	}

	var modelGroups []*model.Group
	for _, g := range groups {
		owner, err := r.UserRepo.GetByID(ctx, g.OwnerID)
		if err != nil || owner == nil {
			continue
		}

		ownerPublic := mapUserToPublic(owner)
		modelGroups = append(modelGroups, mapGroupToModel(g, ownerPublic))
	}
	return modelGroups, nil
}

// MyGroups is the resolver for the myGroups field.
func (r *queryResolver) MyGroups(ctx context.Context) ([]*model.Group, error) {
	user := auth.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	groups, err := r.CommunityRepo.ListGroupsByMember(ctx, user.ID)
	if err != nil {
		return nil, err
	}
	var modelGroups []*model.Group
	for _, g := range groups {
		owner, _ := r.UserRepo.GetByID(ctx, g.OwnerID)
		modelGroups = append(modelGroups, mapGroupToModel(g, mapUserToPublic(owner)))
	}
	return modelGroups, nil
}

// UserGroups is the resolver for the userGroups field.
func (r *queryResolver) UserGroups(ctx context.Context, username string) ([]*model.Group, error) {
	if auth.ForContext(ctx) == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	user, err := r.UserRepo.GetByUsername(ctx, username)
	if err != nil {
		return nil, err
	}

	groups, err := r.CommunityRepo.ListPublicGroupsByMember(ctx, user.ID)
	if err != nil {
		return nil, err
	}
	var modelGroups []*model.Group
	for _, g := range groups {
		owner, _ := r.UserRepo.GetByID(ctx, g.OwnerID)
		modelGroups = append(modelGroups, mapGroupToModel(g, mapUserToPublic(owner)))
	}
	return modelGroups, nil
}

// Group is the resolver for the group field.
func (r *queryResolver) Group(ctx context.Context, slug string) (*model.Group, error) {
	g, err := r.CommunityRepo.GetGroup(ctx, slug)
	if err != nil {
		return nil, err
	}
	owner, _ := r.UserRepo.GetByID(ctx, g.OwnerID)
	ownerPublic := &users.PublicUser{
		ID:          owner.ID,
		Name:        owner.Name,
		Username:    owner.Username,
		DisplayName: owner.DisplayName,
		Gender:      owner.Gender,
		Avatar:      owner.Avatar,
	}
	return mapGroupToModel(g, ownerPublic), nil
}

// GroupByInviteToken is the resolver for the groupByInviteToken field.
func (r *queryResolver) GroupByInviteToken(ctx context.Context, token string) (*model.Group, error) {
	g, err := r.CommunityRepo.GetGroupByInviteToken(ctx, token)
	if err != nil {
		return nil, err
	}
	owner, _ := r.UserRepo.GetByID(ctx, g.OwnerID)
	return mapGroupToModel(g, mapUserToPublic(owner)), nil
}

// Post is the resolver for the post field.
func (r *queryResolver) Post(ctx context.Context, id string) (*model.Post, error) {
	p, err := r.CommunityRepo.GetPost(ctx, id)
	if err != nil {
		return nil, err
	}
	author, _ := r.UserRepo.GetByID(ctx, p.AuthorID)
	authorPublic := &users.PublicUser{
		ID:          author.ID,
		Name:        author.Name,
		Username:    author.Username,
		DisplayName: author.DisplayName,
		Gender:      author.Gender,
		Avatar:      author.Avatar,
	}
	group, _ := r.CommunityRepo.GetGroupByID(ctx, p.GroupID)

	if group.Type == community.GroupTypePrivate {
		user := auth.ForContext(ctx)
		if user == nil {
			return nil, fmt.Errorf("access denied: private group")
		}
		isMember, err := r.CommunityRepo.IsMember(ctx, group.ID, user.ID)
		if err != nil {
			return nil, err
		}
		if !isMember {
			return nil, fmt.Errorf("access denied: must be a member to view post")
		}
	}

	groupOwner, _ := r.UserRepo.GetByID(ctx, group.OwnerID)
	groupOwnerPublic := &users.PublicUser{
		ID:          groupOwner.ID,
		Name:        groupOwner.Name,
		Username:    groupOwner.Username,
		DisplayName: groupOwner.DisplayName,
		Gender:      groupOwner.Gender,
		Avatar:      groupOwner.Avatar,
	}
	return mapPostToModel(p, authorPublic, group, groupOwnerPublic), nil
}

// Comment is the resolver for the comment field.
func (r *queryResolver) Comment(ctx context.Context, id string) (*model.Comment, error) {
	c, err := r.CommunityRepo.GetComment(ctx, id)
	if err != nil {
		return nil, err
	}

	author, _ := r.UserRepo.GetByID(ctx, c.AuthorID)
	authorPublic := &users.PublicUser{
		ID:          author.ID,
		Name:        author.Name,
		Username:    author.Username,
		DisplayName: author.DisplayName,
		Gender:      author.Gender,
		Avatar:      author.Avatar,
	}

	post, _ := r.CommunityRepo.GetPost(ctx, c.PostID)
	postAuthor, _ := r.UserRepo.GetByID(ctx, post.AuthorID)
	postAuthorPublic := &users.PublicUser{
		ID:          postAuthor.ID,
		Name:        postAuthor.Name,
		Username:    postAuthor.Username,
		DisplayName: postAuthor.DisplayName,
		Gender:      postAuthor.Gender,
		Avatar:      postAuthor.Avatar,
	}

	group, _ := r.CommunityRepo.GetGroupByID(ctx, post.GroupID)
	groupOwner, _ := r.UserRepo.GetByID(ctx, group.OwnerID)
	groupOwnerPublic := &users.PublicUser{
		ID:          groupOwner.ID,
		Name:        groupOwner.Name,
		Username:    groupOwner.Username,
		DisplayName: groupOwner.DisplayName,
		Gender:      groupOwner.Gender,
		Avatar:      groupOwner.Avatar,
	}

	result := mapCommentToModel(c, authorPublic, post, postAuthorPublic, group, groupOwnerPublic)

	user := auth.ForContext(ctx)
	if user != nil {
		voteType, _ := r.CommunityRepo.GetUserCommentVote(ctx, user.ID, c.ID)
		switch voteType {
		case "UP":
			result.UserVote = model.VoteTypeUp
		case "DOWN":
			result.UserVote = model.VoteTypeDown
		default:
			result.UserVote = model.VoteTypeNone
		}
	}

	return result, nil
}

// PublicPosts is the resolver for the publicPosts field.
func (r *queryResolver) PublicPosts(ctx context.Context, limit *int32, offset *int32) ([]*model.Post, error) {
	l := 10
	o := 0
	if limit != nil {
		l = int(*limit)
	}
	if offset != nil {
		o = int(*offset)
	}

	posts, err := r.CommunityRepo.ListPublicPosts(ctx, l, o)
	if err != nil {
		return nil, err
	}

	var modelPosts []*model.Post
	for _, p := range posts {
		author, _ := r.UserRepo.GetByID(ctx, p.AuthorID)
		authorPublic := &users.PublicUser{
			ID:          author.ID,
			Name:        author.Name,
			Username:    author.Username,
			DisplayName: author.DisplayName,
			Gender:      author.Gender,
			Avatar:      author.Avatar,
		}

		group, _ := r.CommunityRepo.GetGroupByID(ctx, p.GroupID)
		groupOwner, _ := r.UserRepo.GetByID(ctx, group.OwnerID)
		groupOwnerPublic := &users.PublicUser{
			ID:          groupOwner.ID,
			Name:        groupOwner.Name,
			Username:    groupOwner.Username,
			DisplayName: groupOwner.DisplayName,
			Gender:      groupOwner.Gender,
			Avatar:      groupOwner.Avatar,
		}

		modelPosts = append(modelPosts, mapPostToModel(p, authorPublic, group, groupOwnerPublic))
	}
	return modelPosts, nil
}

// Comment returns CommentResolver implementation.
func (r *Resolver) Comment() CommentResolver { return &commentResolver{r} }

// Group returns GroupResolver implementation.
func (r *Resolver) Group() GroupResolver { return &groupResolver{r} }

// Post returns PostResolver implementation.
func (r *Resolver) Post() PostResolver { return &postResolver{r} }

type commentResolver struct{ *Resolver }
type groupResolver struct{ *Resolver }
type postResolver struct{ *Resolver }
